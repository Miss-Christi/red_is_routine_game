<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pitch Sprint — Updated</title>
<style>
  :root{
    --bg:#bfe9ff; --ground:#1f7a1f; --ui:#fff; --muted:#123;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:var(--muted)}
  #wrap{display:flex;flex-direction:column;align-items:center;min-height:100vh;background:linear-gradient(#cdeeff, #a6dbff 60%);padding:8px 10px;box-sizing:border-box}
  canvas{width:100%;max-width:900px;height:56vh;border-radius:10px;background:transparent;display:block;touch-action:none}
  header{width:100%;max-width:900px;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
  .left{display:flex;flex-direction:column}
  .score{font-weight:700;font-size:16px}
  .small{font-size:12px;color:#234}
  .bigBtn{position:fixed;right:14px;bottom:18px;background:rgba(255,255,255,0.92);border-radius:40px;padding:14px 18px;font-weight:700;box-shadow:0 6px 18px rgba(10,10,10,0.12);z-index:30}
  #overlay{position:relative;max-width:900px;width:100%;margin-top:-56vh;pointer-events:none;display:flex;align-items:center;justify-content:center}
  #menu{background:var(--ui);padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.12);text-align:center;pointer-events:auto}
  #menu h2{margin:2px 0 6px 0}
  .btn{padding:8px 10px;border-radius:8px;background:#f6f6f8;border:1px solid rgba(0,0,0,0.06);cursor:pointer;margin:6px}
  footer{font-size:12px;color:#134;margin-top:8px}
  @media(max-width:420px){ .bigBtn{padding:12px 14px;right:10px;bottom:12px} canvas{height:52vh} }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="left">
      <div class="score" id="scoreTxt">Distance: 0 m</div>
      <div class="small" id="itemsTxt">Items: 0 • Score: 0</div>
    </div>
    <div>
      <button class="btn" id="showLB">Leaderboard</button>
      <button class="btn" id="resetLB">Reset LB</button>
    </div>
  </header>

  <canvas id="game" tabindex="0"></canvas>
  <div id="overlay">
    <!-- center-aligned menu injected here -->
  </div>

  <button class="bigBtn" id="jumpBtn">JUMP</button>
  <footer>Tap anywhere or press JUMP • Avoid obstacles • Collect pads, chocolate, water, footballs</footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const overlay = document.getElementById('overlay');
  const jumpBtn = document.getElementById('jumpBtn');
  const scoreTxt = document.getElementById('scoreTxt');
  const itemsTxt = document.getElementById('itemsTxt');
  const lbBtn = document.getElementById('showLB');
  const resetBtn = document.getElementById('resetLB');
  const ctx = canvas.getContext('2d');

  // responsive canvas
  function sizeCanvas(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = Math.min(window.innerWidth - 16, 900);
    const cssH = Math.round(window.innerHeight * 0.56);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', sizeCanvas);
  sizeCanvas();

  // Game constants (Chrome-dino-ish)
  let STATE = 'menu'; // menu, playing, over
  const GRAVITY = 2000; // px/s^2
  const JUMP_V = -700; // px/s initial
  const BASE_SPEED = 420; // px/s (obstacle travel speed)
  const SPEED_INCREASE = 4; // per second
  const SPAWN_MIN = 1000, SPAWN_MAX = 1800; // ms
  const COIN_SCORE = 10, ITEM_SCORE = 25, BALL_SCORE = 40, MUD_PEN = 15;

  // timing
  let lastTime = 0;
  let worldSpeed = BASE_SPEED;
  let spawnAt = 0;

  // scoring
  let distance = 0; // meters (derived)
  let itemCount = 0;
  let points = 0;

  // player
  const player = {
    x: 90,
    y: 0,
    w: 48,
    h: 64,
    vy: 0,
    onGround: true,
    groundY: 0
  };

  // pools
  const obstacles = []; // active obstacle objects
  const pickups = []; // coins/items/football

  // obstacles types
  // fatal types: 'cramp','kit','aunty' -> instant game over on hit
  // mud -> penalty (not fatal)
  // pickups kinds: 'coin','pad','water','choc','ball'

  // background / stadium
  let stands = [];
  let clouds = [];

  function initBg(){
    clouds = [];
    for(let i=0;i<6;i++) clouds.push({x: Math.random()*canvas.width, y: 20+Math.random()*50, s: 0.6+Math.random()*0.8});
    stands = [];
    const rows = 8;
    for(let i=0;i<rows;i++){
      stands.push({x: i * 220, w: 200 + Math.random()*80, h: 40 + Math.random()*50});
    }
    player.groundY = (canvas.height / (window.devicePixelRatio||1)) - 80; // ground offset
    player.y = player.groundY;
  }

  // spawn helpers
  function spawnObstacle(type){
    const W = canvas.width/(window.devicePixelRatio||1);
    let o = obstacles.find(o=>!o.active);
    if(!o){
      o = {active:true};
      obstacles.push(o);
    } else o.active = true;
    o.type = type;
    o.w = (type==='aunty'?54:(type==='mud'?48:44));
    o.h = (type==='aunty'?68:(type==='mud'?22:40));
    o.x = canvas.width/(window.devicePixelRatio||1) + 20;
    o.y = player.groundY - o.h;
    o.speed = worldSpeed;
    return o;
  }
  function spawnPickup(kind){
    const W = canvas.width/(window.devicePixelRatio||1);
    let p = pickups.find(p=>!p.active);
    if(!p){ p = {active:true}; pickups.push(p); } else p.active = true;
    p.kind = kind;
    p.w = 28; p.h = 28;
    p.x = canvas.width/(window.devicePixelRatio||1) + 20;
    // variable y: coin height or low pickup
    p.y = player.groundY - 60 - (Math.random()*30);
    p.collected = false;
    return p;
  }

  function scheduleSpawn(now){
    spawnAt = now + (SPAWN_MIN + Math.random()*(SPAWN_MAX-SPAWN_MIN));
  }

  // input - pointer and button
  function tryJump(){
    if (STATE !== 'playing') return;
    if (player.onGround){
      player.vy = JUMP_V;
      player.onGround = false;
    }
  }
  canvas.addEventListener('pointerdown', (e)=> { e.preventDefault(); tryJump(); });
  jumpBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); tryJump(); });

  // keyboard fallback
  window.addEventListener('keydown', e=>{
    if (e.key === ' ' || e.key === 'Spacebar') { tryJump(); if (STATE==='menu') startGame(); }
    if (e.key === 'r' && STATE==='over') startGame();
  });

  // collision helper (AABB)
  function intersects(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // draw simple vectors for player/obstacles
  function drawPlayer(ctx, p){
    // body
    ctx.save();
    const bob = (player.onGround? Math.sin(Date.now()/180)/20 : 0);
    ctx.fillStyle = '#1a3b7a';
    roundRect(ctx, p.x, p.y + bob, p.w, p.h, 6); ctx.fill();
    // head
    ctx.fillStyle = '#ffdcb6';
    ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y - 6 + bob, 10, 0, Math.PI*2); ctx.fill();
    // ball at foot (static placed so it makes sense: ball strapped on run)
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x - 14, p.y + p.h - 12, 10, 0, Math.PI*2); ctx.fill();
    // football pattern
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x - 18, p.y + p.h - 14, 3, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawAunty(ctx,o){
    // sari-styled aunty cartoon
    ctx.save();
    ctx.translate(o.x, o.y);
    // body sari triangle
    ctx.fillStyle = '#d9534f'; ctx.beginPath(); ctx.moveTo(10, o.h); ctx.lineTo(o.w/2, 10); ctx.lineTo(o.w-10, o.h); ctx.closePath(); ctx.fill();
    // head
    ctx.fillStyle = '#ffdcb6'; ctx.beginPath(); ctx.arc(o.w/2, 6, 10, 0, Math.PI*2); ctx.fill();
    // glasses
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(o.w/2 -4, 6, 3, 0, Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(o.w/2 +4, 6, 3, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // start & end
  function startGame(){
    STATE = 'playing';
    lastTime = performance.now();
    worldSpeed = BASE_SPEED;
    distance = 0; itemCount = 0; points = 0;
    obstacles.forEach(o=>o.active=false);
    pickups.forEach(p=>p.active=false);
    initBg();
    scheduleSpawn(lastTime + 600);
    overlay.innerHTML = '';
    requestAnimationFrame(loop);
  }

  function gameOver(){
    STATE = 'over';
    points = Math.floor(distance) + itemCount*ITEM_SCORE;
    showGameOver();
  }

  // draw background & stands
  function drawBackground(ctx, W, H, dt){
    ctx.fillStyle = '#cfefff'; ctx.fillRect(0,0,W,H);
    // clouds
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    clouds.forEach(c=>{
      c.x -= (worldSpeed*0.0003) * (c.s*100) * (dt/16);
      if (c.x < -120) c.x = W + 60;
      ctx.beginPath(); ctx.ellipse(c.x, c.y, 36*c.s, 18*c.s, 0,0,Math.PI*2); ctx.fill();
    });
    // stands (stadium look)
    stands.forEach(s=>{
      s.x -= (worldSpeed*0.0006) * (dt/16) * 20;
      if (s.x < -220) s.x = W + Math.random()*120;
      ctx.fillStyle = '#1f7a1f';
      ctx.fillRect(s.x, H - 140 - (s.h/2), s.w, s.h);
      // crowd dots
      ctx.fillStyle = '#7ef07a';
      for(let i=0;i<4;i++) ctx.fillRect(s.x + 8 + i*30, H - 140 - (s.h/2) + 8, 6, 6);
    });

    // pitch / ground
    ctx.fillStyle = '#117a17'; ctx.fillRect(0, H - 80, W, 80);
    // white pitch lines
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, H - 50); ctx.lineTo(W, H -50); ctx.stroke();
  }

  // main loop (dt in ms)
  function loop(now){
    if (STATE !== 'playing') return;
    const dt = Math.min(40, now - lastTime); // ms clamp
    lastTime = now;

    // accelerate worldSpeed gradually (gentle)
    worldSpeed += (SPEED_INCREASE * dt/1000);

    // distance (approx meters) — scale
    distance += (worldSpeed * dt/1000) * 0.9; // tuning

    // player physics (vy in px/s)
    player.vy += GRAVITY * dt/1000;
    player.y += player.vy * dt/1000;
    if (player.y >= player.groundY){ player.y = player.groundY; player.vy = 0; player.onGround = true; }

    // spawning
    if (now >= spawnAt){
      const r = Math.random();
      if (r < 0.45){
        // obstacle cluster
        const types = ['cramp','kit','aunty','mud'];
        const t = types[Math.floor(Math.random()*types.length)];
        spawnObstacle(t);
      } else {
        const kinds = ['coin','pad','water','choc','ball'];
        const k = kinds[Math.floor(Math.random()*kinds.length)];
        // spawn 1-3 pickups in short pattern
        const ccount = 1 + Math.floor(Math.random()*2);
        for(let i=0;i<ccount;i++){
          spawnPickup(k);
          // shift next pickup slightly forward so they appear in cluster
          pickups.filter(p=>p.active).slice(-1)[0].x += i*36;
        }
      }
      scheduleSpawn(now);
    }

    // move obstacles & check collision
    const W = canvas.width/(window.devicePixelRatio||1);
    const H = canvas.height/(window.devicePixelRatio||1);

    for (let o of obstacles){
      if (!o.active) continue;
      o.x -= worldSpeed * dt/1000;
      if (o.x + o.w < -40) { o.active = false; continue; }
      // collision detection with jumping logic:
      // if player's bottom (player.y + player.h) is <= obstacle's top + small margin => player is above obstacle => no collision
      const playerBottom = player.y + player.h - 6; // -6 forgiving
      const obstacleTop = o.y;
      if (intersects(player, o)){
        if (playerBottom <= obstacleTop + 6){
          // player is above obstacle — safe (jumped over)
        } else {
          // hit
          if (o.type === 'mud'){
            // mud is non-fatal, penalty
            o.active = false;
            points = Math.max(0, points - MUD_PEN);
            // small screen flash effect could be added
          } else {
            // fatal
            return gameOver();
          }
        }
      }
    }

    // pickups movement & collection
    for (let p of pickups){
      if (!p.active) continue;
      p.x -= worldSpeed * dt/1000;
      if (p.x + p.w < -40) { p.active = false; continue; }
      if (!p.collected && intersects(player, p)){
        // to collect, ensure player is high enough for airborne pickups? we accept both ground and air
        p.collected = true; p.active = false;
        if (p.kind === 'coin'){ points += COIN_SCORE; }
        else if (p.kind === 'ball'){ points += BALL_SCORE; }
        else points += ITEM_SCORE;
        itemCount += 1;
      }
    }

    // render
    renderFrame(dt);
    // update HUD
    scoreTxt.textContent = `Distance: ${Math.floor(distance)} m`;
    itemsTxt.textContent = `Items: ${itemCount} • Score: ${Math.floor(points)}`;

    requestAnimationFrame(loop);
  }

  // render everything
  function renderFrame(dt){
    const W = canvas.width/(window.devicePixelRatio||1);
    const H = canvas.height/(window.devicePixelRatio||1);
    ctx.clearRect(0,0,W,H);

    drawBackground(ctx, W, H, dt);

    // draw obstacles
    for (let o of obstacles){
      if (!o.active) continue;
      if (o.type === 'cramp'){
        ctx.fillStyle = '#4a1b1b';
        roundRect(ctx, o.x, o.y, o.w, o.h, 6); ctx.fill();
      } else if (o.type === 'kit'){
        ctx.fillStyle = '#b5651d';
        roundRect(ctx, o.x, o.y, o.w, o.h, 6); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.fillRect(o.x+6, o.y+6, o.w-12, 6);
      } else if (o.type === 'mud'){
        ctx.fillStyle = '#6b3f00'; roundRect(ctx, o.x, o.y, o.w, o.h, 4); ctx.fill();
      } else if (o.type === 'aunty'){
        drawAunty(ctx, o);
      }
    }

    // draw pickups
    for (let p of pickups){
      if (!p.active) continue;
      if (p.kind === 'coin'){
        ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, 12, 0, Math.PI*2); ctx.fill();
      } else if (p.kind === 'pad'){
        ctx.fillStyle = '#fff'; roundRect(ctx, p.x, p.y, 28, 16, 4); ctx.fill();
        ctx.fillStyle = '#ff8da1'; ctx.fillRect(p.x+6, p.y+4, 16,8);
      } else if (p.kind === 'water'){
        ctx.fillStyle = '#4fc3f7'; roundRect(ctx, p.x, p.y, 20,26,4); ctx.fill();
      } else if (p.kind === 'choc'){
        ctx.fillStyle = '#5c4033'; roundRect(ctx, p.x, p.y, 28,18,4); ctx.fill();
      } else if (p.kind === 'ball'){
        // simple ball drawing
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x + p.w/2, p.y + p.h/2, 12,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x + p.w/2 -3, p.y + p.h/2 -2, 3,0,Math.PI*2); ctx.fill();
      }
    }

    // draw player (left side)
    drawPlayer(ctx, player);
  }

  // simple pool reset
  function resetAll(){
    obstacles.forEach(o=>o.active=false);
    pickups.forEach(p=>p.active=false);
  }

  // spawn queue setter
  function scheduleSpawn(now){
    spawnAt = now + (SPAWN_MIN + Math.random()*(SPAWN_MAX-SPAWN_MIN));
  }

  // small helper: spawn patterns
  function spawnObstacle(type){
    return spawnObstacleObj(type);
  }

  // concrete spawn creator using previous defined spawn helper functions
  function spawnObstacleObj(type){
    const o = obstacles.find(x=>!x.active) || {};
    o.active = true; o.type = type;
    o.w = (type==='aunty'? 56 : (type==='mud'?48:44));
    o.h = (type==='aunty'? 68 : (type==='mud'?24:40));
    o.x = canvas.width/(window.devicePixelRatio||1) + 10;
    o.y = player.groundY - o.h;
    // put into array if new
    if (!obstacles.includes(o)) obstacles.push(o);
    return o;
  }

  function spawnPickup(kind){
    const p = pickups.find(x=>!x.active) || {};
    p.active = true; p.kind = kind; p.collected = false;
    p.w = 28; p.h = 28;
    p.x = canvas.width/(window.devicePixelRatio||1) + 10;
    p.y = player.groundY - 60 - (Math.random()*24);
    if (!pickups.includes(p)) pickups.push(p);
    return p;
  }

  // Game Over modal + leaderboard (local)
  const LB_KEY = 'pitch_sprint_v2_lb';
  function getLB(){
    try { return JSON.parse(localStorage.getItem(LB_KEY) || '[]'); } catch { return []; }
  }
  function saveLB(name, score){
    const arr = getLB(); arr.push({name:name||'You', score:Math.floor(score), date:Date.now()});
    arr.sort((a,b)=>b.score-a.score);
    localStorage.setItem(LB_KEY, JSON.stringify(arr.slice(0,10)));
  }
  function clearLB(){ localStorage.removeItem(LB_KEY); alert('Leaderboard reset'); }

  resetBtn.addEventListener('click', ()=> clearLB());
  lbBtn.addEventListener('click', ()=> showLB());

  function showLB(){
    const arr = getLB();
    let html = '<div id="menu" style="pointer-events:auto;min-width:220px">';
    html += `<h3>Leaderboard</h3><ol style="text-align:left">`;
    if (!arr.length) html += '<li>No scores yet</li>';
    arr.forEach(s=> html += `<li>${escapeHtml(s.name)} — ${s.score}</li>`);
    html += '</ol><div style="display:flex;gap:8px;justify-content:center"><button class="btn" id="play">Play</button><button class="btn" id="close">Close</button></div></div>'
    overlay.innerHTML = html;
    document.getElementById('play').addEventListener('click', ()=> { overlay.innerHTML=''; startGame(); });
    document.getElementById('close').addEventListener('click', ()=> overlay.innerHTML='');
  }

  function showGameOver(){
    const finalScore = Math.floor(distance) + itemCount*ITEM_SCORE;
    let html = `<div id="menu" style="pointer-events:auto;min-width:260px"><h2>Game Over</h2><div style="font-weight:700">Score: ${Math.floor(points)}</div>`;
    html += `<div style="margin-top:8px"><input id="pname" placeholder="Name (max 12)" maxlength="12" style="width:90%;padding:6px"/></div>`;
    html += `<div style="display:flex;gap:8px;justify-content:center;margin-top:8px"><button class="btn" id="save">Save</button><button class="btn" id="again">Play Again</button></div></div>`;
    overlay.innerHTML = html;
    document.getElementById('save').addEventListener('click', ()=>{
      const n = document.getElementById('pname').value.trim() || 'You';
      saveLB(n, points);
      alert('Saved locally');
      showLB();
    });
    document.getElementById('again').addEventListener('click', ()=> { overlay.innerHTML=''; startGame(); });
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  // initial menu (centered)
  overlay.innerHTML = `<div id="menu" style="pointer-events:auto;text-align:center"><h2 style="margin:6px 0">Pitch Sprint</h2><div style="font-size:13px;margin-bottom:8px">Tap to jump • Collect pads, chocolate, footballs • Avoid cramps & snags</div><div><button class="btn" id="start">Play</button><button class="btn" id="lb">Leaderboard</button></div></div>`;
  document.getElementById('start').addEventListener('click', ()=> { overlay.innerHTML=''; startGame(); });
  document.getElementById('lb').addEventListener('click', ()=> showLB());

  // small pre-init
  initBg();
  renderIdle();

  // idle render while in menu
  function renderIdle(){
    const W = canvas.width/(window.devicePixelRatio||1), H = canvas.height/(window.devicePixelRatio||1);
    ctx.clearRect(0,0,W,H);
    drawBackground(ctx, W, H, 16);
    // draw a static player
    drawPlayer(ctx, player);
    requestAnimationFrame(()=>{
      if (STATE==='menu') renderIdle();
    });
  }

})();
</script>
</body>
</html>
