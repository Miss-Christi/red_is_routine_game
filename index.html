<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Red is Routine Game</title>
<style>
    :root {
      --bg: #bfe9ff;
      --ground: #1f7a1f;
      --ui: #fff;
      --muted: #123;
    }
  
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--muted);
    }
  
    #wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(#cdeeff, #a6dbff 60%);
      padding: 8px;
      box-sizing: border-box;
    }
  
    canvas {
      width: 100%;
      max-width: 900px;
      height: 56vh;
      border-radius: 10px;
      background: transparent;
      display: block;
      touch-action: none;
    }
  
    header {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
  
    .left {
      display: flex;
      flex-direction: column;
    }
  
    .score {
      font-weight: 700;
      font-size: 16px;
    }
  
    .small {
      font-size: 12px;
      color: #234;
    }
  
    .bigBtn {
      position: fixed;
      right: 14px;
      bottom: 18px;
      background: rgba(255, 255, 255, 0.96);
      border-radius: 40px;
      padding: 14px 18px;
      font-weight: 700;
      box-shadow: 0 6px 18px rgba(10, 10, 10, 0.12);
      z-index: 30;
    }
  
    /* overlay fixed for stable mobile input */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
      background: rgba(0, 0, 0, 0);
      transition: background 160ms ease;
    }
  
    #overlay.show {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.35);
    }
  
    #menu {
      max-width: 92%;
      box-sizing: border-box;
      background: var(--ui);
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      text-align: center;
    }
  
    .btn {
      padding: 8px 10px;
      border-radius: 8px;
      background: #f6f6f8;
      border: 1px solid rgba(0, 0, 0, 0.06);
      cursor: pointer;
      margin: 6px;
    }
  
    footer {
      font-size: 12px;
      color: #134;
      margin-top: 8px;
    }
  
    input[type="text"] {
      padding: 6px;
      border-radius: 6px;
      border: 1px solid #ccc;
    }
  
    @media (max-width: 420px) {
      .bigBtn {
        padding: 12px 14px;
        right: 10px;
        bottom: 12px;
      }
  
      canvas {
        height: 52vh;
      }
  
      #menu {
        font-size: 16px;
        padding: 12px;
      }
  
      .btn {
        padding: 12px 14px;
        font-size: 15px;
      }
  
      input[type="text"] {
        font-size: 16px;
      }
    }
  </style>
  
</head>
<body>
<div id="wrap">
  <header>
    <div class="left">
      <div class="score" id="scoreTxt">Distance: 0 m</div>
      <div class="small" id="itemsTxt">Items: 0 • Score: 0</div>
    </div>
    <div></div>
  </header>

  <canvas id="game" tabindex="0"></canvas>
  <div id="overlay"></div>

  <button class="bigBtn" id="jumpBtn">JUMP</button>
  <footer style="text-align:center;color:white">Tap anywhere on the game or press JUMP • Jump to collect points • Avoid obstacles</footer>
</div>

<script>
(() => {
  // Elements + context
  const canvas = document.getElementById('game');
  const overlay = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');

  // Global PIXEL RATIO used everywhere to avoid mismatch
  let PIXEL_RATIO = 1;

  // Size canvas robustly (visualViewport aware) and cap DPR for mobile performance
  function sizeCanvas(){
    const v = window.visualViewport || { width: window.innerWidth, height: window.innerHeight };
    const cssW = Math.min(v.width - 16, 900);
    const cssH = Math.round(v.height * 0.56);
    const rawDpr = window.devicePixelRatio || 1;
    const dpr = Math.min(rawDpr, 1.2); // cap for mobile
    PIXEL_RATIO = dpr;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', sizeCanvas);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', sizeCanvas);
  sizeCanvas();

  // Overlay helpers (use these instead of overlay.innerHTML directly)
  function showOverlay(html){
    overlay.innerHTML = html;
    overlay.classList.add('show');
    const input = overlay.querySelector('input, textarea');
    if (input) setTimeout(()=> { try{ input.focus(); } catch(e){} }, 70);
  }
  function hideOverlay(){
    overlay.classList.remove('show');
    setTimeout(()=> { overlay.innerHTML = ''; }, 0);
  }

  // Game constants
  let STATE = 'menu'; // menu | playing | hit | over
  const GRAVITY = 2200, JUMP_V = -760;
  const BASE_SPEED = 360, SPEED_INCREASE = 6;
  const SPAWN_MIN = 1200, SPAWN_MAX = 1800;
  const DISTANCE_SCALE = 0.06;
  const COIN_SCORE = 10, ITEM_SCORE = 25, BALL_SCORE = 40, MUD_PEN = 15;

  // Runtime
  let lastTime = 0, worldSpeed = 0, spawnAt = 0;
  let distance = 0, itemCount = 0, points = 0;

  const player = { x: 40, y: 0, w: 66, h: 74, vy: 0, onGround: true, groundY: 0, animTimer:0, runFlip:false };
  const obstacles = [], pickups = [];

  // Assets (keep these next to the HTML)
  const assets = {
    'girlRun1':'Girl-Running_1_bg.png',
    'girlRun2':'Girl-Running_2_bg.png',
    'girlJump':'Girl-Jumping_bg.png',
    'girlFall':'Girl-Falling_bg.png',
    'aunty':'Angry_Aunty.png',
    'shoes':'Old_Shoes_bg.png',
    'choc':'Chocolate_bg.png',
    'coin':'Coin_bg.png',
    'dizzy':'dizzy-emoji_bg.png',
    'pad':'Pad_bg.png',
    'stain':'Stain_bg.png',
    'water':'Water.png',
    'ball':'Football_bg.png'
  };
  const imgs = {};
  let loaded = 0, total = Object.keys(assets).length;
  function preload(cb){
    for (const k in assets){
      const im = new Image();
      im.src = assets[k];
      im.onload = ()=>{ imgs[k]=im; loaded++; if (loaded===total) cb(); };
      im.onerror = ()=>{ console.warn('Missing image', assets[k]); loaded++; if (loaded===total) cb(); };
    }
  }

  // Background generation
  let clouds = [], stands = [];
  function initBg(){
    const W = canvas.width / PIXEL_RATIO;
    clouds = []; for (let i=0;i<6;i++) clouds.push({x: Math.random()*W, y: 18+Math.random()*50, s: 0.6+Math.random()*0.8});
    stands = [];
    const standWidth = 220, standHeight = 120;
    for (let i=0;i<10;i++) stands.push({ x: i * standWidth, w: standWidth, h: standHeight });
    const H = canvas.height / PIXEL_RATIO;
    player.groundY = H - 86; player.y = player.groundY; player.vy = 0; player.onGround = true;
  }

  // Spawn helpers
  function spawnObstacle(type){
    let o = obstacles.find(x=>!x.active);
    if (!o) { o = {}; obstacles.push(o); }
    o.active = true; o.type = type;
    const base = { 'aunty':[42,56], 'shoes':[45,33], 'stain':[44,36], 'dizzy':[22,22], 'mud':[52,28], 'kit':[54,42], 'cramp':[44,40] };
    const b = base[type] || [52,40];
    const scale = (type==='stain'?2.0:1.6);
    o.w = Math.round(b[0] * scale); o.h = Math.round(b[1] * scale);
    const W = canvas.width / PIXEL_RATIO;
    const footOffset = 4;
    o.x = W + 30;
    o.y = (player.groundY + player.h) - o.h - footOffset;
    const H = canvas.height / PIXEL_RATIO;
    if (o.y + o.h > H) o.y = H - o.h - 4;
  }

  function spawnPickup(kind, offsetX=0){
    let p = pickups.find(x=>!x.active);
    if (!p) { p = {}; pickups.push(p); }
    p.active = true; p.kind = kind;
    const sz = { coin:46, choc:52, pad:48, water:44, ball:44 };
    const s = sz[kind] || 44;
    p.w = s; p.h = s;
    const W = canvas.width / PIXEL_RATIO;
    p.x = W + 30 + offsetX;
    p.y = player.groundY - 86 - (Math.random()*18);
    p.collected = false;
  }

  function scheduleSpawn(now){ spawnAt = now + (SPAWN_MIN + Math.random()*(SPAWN_MAX-SPAWN_MIN)); }

  // Input (use passive:false for touchstart that preventDefault)
  function doJump(){ if (STATE !== 'playing') return; 
  if (player.onGround){ 
    player.vy = JUMP_V; player.onGround = false; 
    player.animTimer = 0; 
    } }
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); doJump(); }, { passive: false });
  document.getElementById('jumpBtn').addEventListener('pointerdown', e=>{ e.preventDefault(); doJump(); }, { passive: false });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); doJump(); }, { passive: false });
  window.addEventListener('keydown', e=>{ 
    if (e.key===' '||e.key==='Spacebar'){ 
        if (STATE==='menu') startGame(); 
        doJump(); 
        e.preventDefault(); 
    } 
    if (e.key==='r'&&STATE==='over') startGame(); 
});

  // Draw helpers
  function roundRect(ctx,x,y,w,h,r){ 
    ctx.beginPath();
    ctx.moveTo(x+r,y); 
    ctx.arcTo(x+w,y,x+w,y+h,r); 
    ctx.arcTo(x+w,y+h,x,y+h,r); 
    ctx.arcTo(x,y+h,x,y,r); 
    ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); 
}
  function drawBall(ctx,x,y,rad){ 
    ctx.fillStyle='#fff';
    ctx.beginPath();
    ctx.arc(x,y,rad,0,Math.PI*2);
    ctx.fill(); ctx.fillStyle='#000';
    ctx.beginPath(); ctx.arc(x-4,y-2,2.5,0,Math.PI*2);
    ctx.fill(); ctx.beginPath();
    ctx.arc(x+5,y+1,2.5,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+1,y-6,2.2,0,Math.PI*2);
    ctx.fill();
}

  function drawBackground(ctx,W,H,dt,moving){
    // clear full pixel buffer first to avoid trails
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#cfefff'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    clouds.forEach(c=>{
        if (moving) c.x -= (worldSpeed*0.000002) * (c.s*100) * (dt/16); 
        if (c.x < -120) c.x = W + 60;
        ctx.beginPath(); 
        ctx.ellipse(c.x, c.y, 34*c.s, 18*c.s, 0,0,Math.PI*2);
        ctx.fill(); 
    });

    // draw stands (kept simple but full width)
    const standHeight = 120;
    const standY = H - 88; // ground anchor
    for (const s of stands){
      if (moving) s.x -= (worldSpeed * 0.00045) * (dt/16) * 20;
      if (s.x < -s.w) s.x = s.w * (Math.ceil(W / s.w) + 1);
      const topY = standY - standHeight;
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(s.x, topY, s.w, standHeight);
      ctx.fillStyle = '#A0522D';
      const steps = 5; const stepH = standHeight / steps; const stepW = s.w / steps;
      for (let i=0;i<steps;i++) ctx.fillRect(s.x + i*stepW, topY + i*stepH, stepW, stepH);
      ctx.fillStyle = '#A0522D';
      const seatRows=3, seatCols=6, seatW=(s.w/seatCols)-3, seatH=(standHeight/8);
      for (let r=0;r<seatRows;r++) 
      for (let c=0;c<seatCols;c++) ctx.fillRect(s.x + c*(seatW+3), topY + 10 + r*(seatH+6), seatW, seatH);
    }

    // ground (ensure full width by using logical W)
    ctx.fillStyle = '#117a17';
    ctx.fillRect(0, H - 88, W, 88);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, H - 54); ctx.lineTo(W, H - 54); 
    ctx.stroke();
  }

  function drawObstacle(ctx,o){
    if (!o.active) return;
    const map = { 'aunty':'aunty','shoes':'shoes','stain':'stain','dizzy':'dizzy','cramp':'stain','kit':'shoes','mud':'shoes' };
    const key = map[o.type] || o.type;
    const im = imgs[key];
    if (im) ctx.drawImage(im, o.x, o.y, o.w, o.h);
    else { ctx.fillStyle='#7a1b1b'; 
        roundRect(ctx, o.x, o.y, o.w, o.h, 6); ctx.fill(); 
    }
  }

  function drawPickup(ctx,p){
    if (!p.active) return;
    if (p.kind === 'ball'){ const im = imgs['ball'];
    if (im) ctx.drawImage(im, p.x, p.y, p.w, p.h);
    else drawBall(ctx, p.x + p.w/2, p.y + p.h/2, 12);
    return;
}
    const map = { coin:'coin', choc:'choc', pad:'pad', water:'water' };
    const im = imgs[ map[p.kind] || 'coin' ];
    if (im) ctx.drawImage(im, p.x, p.y, p.w, p.h);
    else { ctx.fillStyle='#ffd700'; ctx.beginPath();
    ctx.arc(p.x + p.w/2, p.y + p.h/2, 12, 0, Math.PI*2);
    ctx.fill(); }
  }

  // rotating football in front of the player
  let footballAngle = 0;
  function drawRotatingFootball(ctx, now){
    const size = 36;
    footballAngle = (footballAngle + 0.19) % (Math.PI*2);
    const centerX = player.x + 54;
    const centerY = player.y + player.h - 26;
    if (imgs['ball']){
      ctx.save();
      ctx.translate(centerX + size/2, centerY + size/2); 
      ctx.rotate(footballAngle); 
      ctx.drawImage(imgs['ball'], -size/2, -size/2, size, size); 
      ctx.restore();
    } else { 
        ctx.save(); 
        ctx.translate(centerX + size/2, centerY + size/2);
        ctx.rotate(footballAngle);
        drawBall(ctx, 0,0,12);
        ctx.restore(); 
    }
  }

  // draw player
  let fallUntil = 0;
  function drawPlayer(ctx, now) {
  drawRotatingFootball(ctx, now);

  const runA = imgs['girlRun1'];
  const runB = imgs['girlRun2'];
  const jump = imgs['girlJump'];
  const fall = imgs['girlFall'];

  const x = player.x;
  const y = player.y;
  const w = player.w;
  const h = player.h;

  if (STATE === 'hit') {
    if (fall) {
      ctx.drawImage(fall, x - 8, y - 8, w + 16, h + 16);
    } else {
      ctx.fillStyle = '#ffb3a7';
      roundRect(ctx, x, y, w, h, 10);
      ctx.fill();
    }
    return;
  }

  if (STATE === 'over' && imgs['girlFall']) {
    ctx.drawImage(imgs['girlFall'], x - 8, y - 8, w + 16, h + 16);
    return;
  }

  if (!player.onGround && jump) {
    ctx.drawImage(jump, x - 8, y - 8, w + 16, h + 16);
    return;
  }

  player.animTimer += 16;
  if (player.animTimer > 140) {
    player.runFlip = !player.runFlip;
    player.animTimer = 0;
  }

  if (player.runFlip && runB) {
    ctx.drawImage(runB, x - 8, y - 6, w + 16, h + 16);
  } else if (runA) {
    ctx.drawImage(runA, x - 8, y - 6, w + 16, h + 16);
  } else {
    ctx.fillStyle = '#1a3b7a';
    roundRect(ctx, x, y, w, h, 8);
    ctx.fill();
    
    ctx.fillStyle = '#ffdcb6';
    ctx.beginPath();
    ctx.arc(x + w / 2, y - 8, 10, 0, Math.PI * 2);
    ctx.fill();
  }
}


  // ---------- flow ----------
  function startGame(){
    STATE = 'playing';
    lastTime = performance.now();
    worldSpeed = BASE_SPEED;
    distance = 0; itemCount = 0; points = 0;
    obstacles.forEach(o=>o.active=false);
    pickups.forEach(p=>p.active=false);
    initBg();
    scheduleSpawn(lastTime + 600);
    hideOverlay();
    requestAnimationFrame(loop);
  }

  function triggerHit(now){
    STATE = 'hit';
    if (player.onGround) player.vy = 240;
    player.vy = Math.max(player.vy, 200);
    player.onGround = false;
    fallUntil = now + 1500;
    requestAnimationFrame(loop);
  }

  function showGameOver(){
  try {
    const gameOverPhrases = [
      "70% girls struggle to play during periods.",
      "Nearly 50% girls say coaches avoid talking about periods.",
      "60% girls worry about period leaks while playing",
    ];
    STATE = 'over';
    const finalScore = Math.floor(distance) + Math.floor(points);
    const randomPhrase = gameOverPhrases[Math.floor(Math.random() * gameOverPhrases.length)];

    let html = `<div id="menu" style="pointer-events:auto;min-width:300px;text-align:center"><h2>Game Over</h2>`;
    html += `<div style="font-weight:700;color:#333;font-size:16px;margin-top:6px">${randomPhrase}</div>`;
    html += `<div style="margin-top:8px; display:flex; justify-content: center; align-items:center; gap:8px;">
      <div style="font-weight:700; color:red; font-size:16px; margin-bottom:0; padding-right:8px">Red is Routine</div>
      <img src="Logo_Red_Is_Routine.png" alt="Red is routine" style="width:15%; padding-left:8px; height:auto;">
      </div>`;
    html += `<div style="font-size:14px;color:#444;margin-bottom:8px">"A menstrual health campaign by #NoFoulPlay"</div>`;
    html += `<div style="font-weight:700;margin-bottom:8px">Score: ${Math.floor(finalScore)}</div>`;
    html += `<div style="display:flex;gap:8px;justify-content:center;margin-top:8px">
        <button style="background-color:#ff7f7f" class="btn" id="again">Play Again</button>
        <button class="btn" id="home" style="background-color:#ff7f7f">Home</button>
        </div></div>`;

    // show overlay (inserts HTML and toggles .show)
    showOverlay(html);

    // attach listeners after DOM is updated
    queueMicrotask(() => {
    const again = document.getElementById('again');
    const home = document.getElementById('home');

    if (again) again.onclick = () => {
        hideOverlay();
        startGame();
    };

    if (home) home.onclick = () => {
        showMenu();
    };
    });


  } catch (err) {
    console.error('showGameOver fatal error', err);
    // fallback minimal overlay so user can still recover
    showOverlay('<div id="menu"><h2>Game Over</h2><div><button class="btn" id="again">Play Again</button></div></div>');
    setTimeout(()=> {
      const again = document.getElementById('again');
      if (again) again.addEventListener('click', ()=> { hideOverlay(); startGame(); }, { once: true });
    }, 60);
  }
}


  // ---------- main loop ----------
  function loop(now){
    try {
      if (!(STATE === 'playing' || STATE === 'hit')) return;
      const dt = Math.min(40, now - lastTime); lastTime = now;

      if (STATE === 'hit'){
        player.vy += GRAVITY * dt/1000;
        player.y += player.vy * dt/1000;
        const H = canvas.height / PIXEL_RATIO;
        if (player.y >= player.groundY){
            player.y = player.groundY;
            player.vy = 0;
            player.onGround = true;
        }
        const W = canvas.width / PIXEL_RATIO;
        drawBackground(ctx, W, H, dt, true);
        obstacles.forEach(o=> drawObstacle(ctx,o));
        pickups.forEach(p=> drawPickup(ctx,p));
        drawPlayer(ctx, now);
        if (now >= fallUntil){ showGameOver(); return; }
        requestAnimationFrame(loop); return;
      }

      // playing
      worldSpeed += (SPEED_INCREASE * dt/1000);
      distance += (worldSpeed * dt/1000) * DISTANCE_SCALE;

      player.vy += GRAVITY * dt/1000;
      player.y += player.vy * dt/1000;
      if (player.y >= player.groundY){
        player.y = player.groundY;
        player.vy = 0;
        player.onGround = true;
    }

      if (now >= spawnAt){
        const r = Math.random();
        if (r < 0.5){
          const types = ['stain','aunty','shoes','dizzy','mud','kit','cramp'];
          spawnObstacle(types[Math.floor(Math.random()*types.length)]);
        } else {
          const kinds = ['coin','choc','pad','water','ball'];
          const k = kinds[Math.floor(Math.random()*kinds.length)];
          const count = 1 + Math.floor(Math.random()*2);
          for (let i=0;i<count;i++) spawnPickup(k, i*36);
        }
        scheduleSpawn(now);
      }

      const W = canvas.width / PIXEL_RATIO;
      const H = canvas.height / PIXEL_RATIO;

      for (const o of obstacles){
        if (!o.active) continue;
        o.x -= worldSpeed * dt/1000;
        if (o.x + o.w < -120){ o.active = false; continue; }
        const playerBottom = player.y + player.h - 6;
        const obstacleTop = o.y;
        if (intersectRects(player, o)){
          if (playerBottom <= obstacleTop + 8){
            // jumped over
          } else {
            if (o.type === 'mud'){
                o.active = false;
                points = Math.max(0, points - MUD_PEN);
            }
            else { triggerHit(now); return; }
          }
        }
      }

      for (const p of pickups){
        if (!p.active) continue;
        p.x -= worldSpeed * dt/1000;
        if (p.x + p.w < -120){ p.active = false; continue; }
        if (!p.collected && intersectRects(player, p)){
          p.collected = true; p.active = false;
          if (p.kind === 'coin') points += COIN_SCORE;
          else if (p.kind === 'ball') points += BALL_SCORE;
          else points += ITEM_SCORE;
          itemCount++;
        }
      }

      drawBackground(ctx, W, H, dt, true);
      obstacles.forEach(o=> drawObstacle(ctx,o));
      pickups.forEach(p=> drawPickup(ctx,p));
      drawPlayer(ctx, now);

      document.getElementById('scoreTxt').textContent = `Distance: ${Math.floor(distance)} m`;
      document.getElementById('itemsTxt').textContent = `Items: ${itemCount} • Score: ${Math.floor(points)}`;

      requestAnimationFrame(loop);
    } catch (err) {
      console.error('Game loop error:', err);
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }
  }

  function intersectRects(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

  function showMenu(){
  try {
    const html = `<div id="menu" style="pointer-events:auto;text-align:center"><h2 style="margin:6px 0">The Red is Routine Game</h2><div style="font-size:13px;margin-bottom:8px">Tap to jump • Jump to collect points • Avoid obstacles</div><div><button class="btn" id="start" style="background-color:#ff7f7f">Play</button></div></div>`;
    showOverlay(html);

    // attach safely
    try {
      const startBtn = document.getElementById('start');
      if (startBtn) {
        startBtn.addEventListener('click', ()=> {
          try { hideOverlay(); startGame(); } catch(e){ console.error(e); }
        }, { once: true });
      } else {
        console.warn('showMenu: #start not found');
        // last-resort attach after short delay
        setTimeout(()=> {
          const s = document.getElementById('start');
          if (s) s.addEventListener('click', ()=> { hideOverlay(); startGame(); }, { once: true });
        }, 60);
      }
    } catch (attachErr){
      console.error('showMenu attach error', attachErr);
    }
  } catch (err){
    console.error('showMenu fatal', err);
    // fallback
    showOverlay('<div id="menu"><h2>Play</h2><button class="btn" id="start">Start</button></div>');
    setTimeout(()=> { const st = document.getElementById('start'); if (st) st.addEventListener('click', ()=> { hideOverlay(); startGame(); }); }, 60);
  }
}


  // Init
  preload(()=>{ initBg(); showMenu(); renderStatic(); });

  function renderStatic(){
    const W = canvas.width / PIXEL_RATIO, H = canvas.height / PIXEL_RATIO;
    drawBackground(ctx,W,H,0,false);
    if (imgs['girlRun1']) ctx.drawImage(imgs['girlRun1'], player.x-8, player.y-6, player.w+16, player.h+16);
  }
})();
</script>
</body>
</html>
